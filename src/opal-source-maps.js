Opal.modules["base64"] = function(Opal) {/* Generated by Opal 1.4.0 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $defs = Opal.defs, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs('raise,delete');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Base64');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var encode, decode;

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    encode = function (input) {
      var str = String(input);
      /* eslint-disable */
      for (
        // initialize result and counter
        var block, charCode, idx = 0, map = chars, output = '';
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = '=', idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3/4);
        if (charCode > 0xFF) {
          self.$raise($$('ArgumentError'), "invalid character (failed: The string to be encoded contains characters outside of the Latin1 range.)");
        }
        block = block << 8 | charCode;
      }
      return output;
      /* eslint-enable */
    };

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    decode = function (input) {
      var str = String(input).replace(/=+$/, '');
      if (str.length % 4 == 1) {
        self.$raise($$('ArgumentError'), "invalid base64 (failed: The string to be decoded is not correctly encoded.)");
      }
      /* eslint-disable */
      for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
          // and if not first of each 4 characters,
          // convert the first 8 bits to one ascii character
          bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
      }
      return output;
      /* eslint-enable */
    };
  ;
    $defs(self, '$decode64', function $$decode64(string) {
      
      return decode(string.replace(/\r?\n/g, ''));
    }, 1);
    $defs(self, '$encode64', function $$encode64(string) {
      
      return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
    }, 1);
    $defs(self, '$strict_decode64', function $$strict_decode64(string) {
      
      return decode(string);
    }, 1);
    $defs(self, '$strict_encode64', function $$strict_encode64(string) {
      
      return encode(string);
    }, 1);
    $defs(self, '$urlsafe_decode64', function $$urlsafe_decode64(string) {
      
      return decode(string.replace(/\-/g, '+').replace(/_/g, '/'));
    }, 1);
    return $defs(self, '$urlsafe_encode64', function $$urlsafe_encode64(string, $kwargs) {
      var padding, str = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      padding = $kwargs.$$smap["padding"];
      if (padding == null) padding = true;
      str = encode(string).replace(/\+/g, '-').replace(/\//g, '_');
      if (!$truthy(padding)) {
        str = str.$delete("=")
      };
      return str;
    }, -2);
  })($nesting[0], $nesting)
};

Opal.modules["json"] = function(Opal) {/* Generated by Opal 1.4.0 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus, $Object = Opal.Object, $hash2 = Opal.hash2, $eqeqeq = Opal.eqeqeq, $defs = Opal.defs, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('raise,new,push,[]=,-,[],create_id,json_create,const_get,attr_accessor,create_id=,===,parse,generate,from_object,merge,to_json,responds_to?,to_io,write,to_s,to_a,strftime');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'JSON');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $writer = nil;

    
    $klass($nesting[0], $$('StandardError'), 'JSONError');
    $klass($nesting[0], $$('JSONError'), 'ParserError');
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise($$$($$('JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'undefined':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (options.array_class).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (options.object_class).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                (($writer = [k, to_opal(value[k], options)]), $send((hash), '[]=', $to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
              }
            }

            if (!options.parse && (klass = (hash)['$[]']($$('JSON').$create_id())) != nil) {
              return $Object.$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    
    $writer = ["json_class"];
    $send(self, 'create_id=', $to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    $defs(self, '$[]', function $JSON_$$$1(value, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      if ($eqeqeq($$('String'), value)) {
        return self.$parse(value, options)
      } else {
        return self.$generate(value, options)
      };
    }, -2);
    $defs(self, '$parse', function $$parse(source, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      return self.$from_object($parse(source), options.$merge($hash2(["parse"], {"parse": true})));
    }, -2);
    $defs(self, '$parse!', function $JSON_parse$excl$2(source, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      return self.$parse(source, options);
    }, -2);
    $defs(self, '$load', function $$load(source, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      return self.$from_object($parse(source), options);
    }, -2);
    $defs(self, '$from_object', function $$from_object(js_object, options) {
      var $ret_or_1 = nil, $writer = nil;

      
      
      if (options == null) options = $hash2([], {});;
      if ($truthy(($ret_or_1 = options['$[]']("object_class")))) {
        $ret_or_1
      } else {
        
        $writer = ["object_class", $$('Hash')];
        $send(options, '[]=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      if ($truthy(($ret_or_1 = options['$[]']("array_class")))) {
        $ret_or_1
      } else {
        
        $writer = ["array_class", $$('Array')];
        $send(options, '[]=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return to_opal(js_object, options.$$smap);;
    }, -2);
    $defs(self, '$generate', function $$generate(obj, options) {
      
      
      
      if (options == null) options = $hash2([], {});;
      return obj.$to_json(options);
    }, -2);
    return $defs(self, '$dump', function $$dump(obj, io, limit) {
      var self = this, string = nil;

      
      
      if (io == null) io = nil;;
      
      if (limit == null) limit = nil;;
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()
        };
        io.$write(string);
        return io;
      } else {
        return string
      };
    }, -2);
  })($nesting[0], $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, 0)
  })($nesting[0], null);
  (function($base) {
    var self = $module($base, 'Enumerable');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    }, 0)
  })($nesting[0]);
  (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(',') + ']';
    
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Hash');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
      }

      return '{' + result.join(',') + '}';
    
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_json', function $$to_json() {
      
      return "null"
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.toString();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return JSON.stringify(self);
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Time');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    }, 0)
  })($nesting[0], null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Date');

    
    
    
    $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, 0);
    return $def(self, '$as_json', function $$as_json() {
      var self = this;

      return self.$to_s()
    }, 0);
  })($nesting[0], null);
};

Opal.modules["opal/source_map/map"] = function(Opal) {/* Generated by Opal 1.4.0 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $to_ary = Opal.to_ary;

  Opal.add_stubs('require,map,to_json,to_h,to_s,delete,encode64,generated_code');
  
  self.$require("base64");
  self.$require("json");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Map');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$to_h', function $$to_h() {
      var self = this, $ret_or_1 = nil;
      if (self.to_h == null) self.to_h = nil;

      if ($truthy(($ret_or_1 = self.to_h))) {
        return $ret_or_1
      } else {
        return self.$map()
      }
    }, 0);
    
    $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_h().$to_json()
    }, 0);
    
    $def(self, '$as_json', function $$as_json($a) {
      var $post_args, $rest_arg, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return self.$to_h();
    }, -1);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.$to_h().$to_s()
    }, 0);
    
    $def(self, '$to_data_uri_comment', function $$to_data_uri_comment() {
      var self = this;

      return "//# sourceMappingURL=data:application/json;base64," + ($$('Base64').$encode64(self.$to_json()).$delete("\n"))
    }, 0);
    
    $def(self, '$cache', function $$cache() {
      var self = this, $ret_or_1 = nil;
      if (self.to_h == null) self.to_h = nil;

      
      self.to_h = ($truthy(($ret_or_1 = self.to_h)) ? ($ret_or_1) : (self.$map()));
      return self;
    }, 0);
    
    $def(self, '$marshal_dump', function $$marshal_dump() {
      var self = this;

      return [self.$to_h(), self.$generated_code()]
    }, 0);
    return $def(self, '$marshal_load', function $$marshal_load(value) {
      var $a, $b, self = this;

      return $b = value, $a = $to_ary($b), (self.to_h = ($a[0] == null ? nil : $a[0])), (self.generated_code = ($a[1] == null ? nil : $a[1])), $b
    }, 1);
  })($$$($$('Opal'), 'SourceMap'), $nesting);
};

Opal.modules["opal/source_map/file"] = function(Opal) {/* Generated by Opal 1.4.0 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $send = Opal.send, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus, $def = Opal.def, $truthy = Opal.truthy, $hash2 = Opal.hash2, $rb_lt = Opal.rb_lt, $to_ary = Opal.to_ary, $rb_plus = Opal.rb_plus, $not = Opal.not;

  Opal.add_stubs('include,attr_reader,new,size,[]=,-,join,map,to_proc,file,force_encoding,source,names,encode_mappings,relative_mappings,absolute_mappings,sort_by,to_a,line,<,column,source_map_name,[],to_s,to_int,each,fragments_by_line,skip_source_map?,is_a?,<<,segment_from_fragment,+,private,flat_map,fragments,code,split,with_index,!,zero?,last');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.generated_code = $proto.fragments = $proto.names = $proto.names_map = $proto.relative_mappings = $proto.absolute_mappings = nil;
    
    self.$include($$$($$$($$('Opal'), 'SourceMap'), 'Map'));
    self.$attr_reader("fragments");
    self.$attr_reader("file");
    self.$attr_reader("source");
    
    $def(self, '$initialize', function $$initialize(fragments, file, source, generated_code) {
      var self = this;

      
      
      if (generated_code == null) generated_code = nil;;
      self.fragments = fragments;
      self.file = file;
      self.source = source;
      self.names_map = $send($$('Hash'), 'new', [], function $$1(hash, name){var $writer = nil;

        
        
        if (hash == null) hash = nil;;
        
        if (name == null) name = nil;;
        $writer = [name, hash.$size()];
        $send(hash, '[]=', $to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, 2);
      self.generated_code = generated_code;
      return (self.absolute_mappings = nil);
    }, -4);
    
    $def(self, '$generated_code', function $$generated_code() {
      var self = this, $ret_or_1 = nil;

      return (self.generated_code = ($truthy(($ret_or_1 = self.generated_code)) ? ($ret_or_1) : ($send(self.fragments, 'map', [], "code".$to_proc()).$join())))
    }, 0);
    
    $def(self, '$map', function $$map($kwargs) {
      var source_root, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      source_root = $kwargs.$$smap["source_root"];
      if (source_root == null) source_root = "";
      return $hash2(["version", "sourceRoot", "sources", "sourcesContent", "names", "mappings"], {"version": 3, "sourceRoot": source_root, "sources": [self.$file()], "sourcesContent": [self.$source().$force_encoding("UTF-8")], "names": self.$names(), "mappings": $$$($$$($$('Opal'), 'SourceMap'), 'VLQ').$encode_mappings(self.$relative_mappings())});
    }, -1);
    
    $def(self, '$names', function $$names() {
      var self = this, $ret_or_1 = nil;

      return (self.names = ($truthy(($ret_or_1 = self.names)) ? ($ret_or_1) : ((self.$absolute_mappings(), $send($send(self.names_map.$to_a(), 'sort_by', [], function $$2(_, index){
        
        
        if (_ == null) _ = nil;;
        
        if (index == null) index = nil;;
        return index;}, 2), 'map', [], function $$3(name, _){
        
        
        if (name == null) name = nil;;
        
        if (_ == null) _ = nil;;
        return name;}, 2)))))
    }, 0);
    
    $def(self, '$segment_from_fragment', function $$segment_from_fragment(fragment, generated_column) {
      var self = this, source_index = nil, original_line = nil, $ret_or_1 = nil, original_column = nil, map_name_index = nil, $writer = nil;

      
      source_index = 0;
      original_line = $rb_minus(($truthy(($ret_or_1 = fragment.$line())) ? ($ret_or_1) : (0)), 1);
      if ($truthy($rb_lt(original_line, 0))) {
        original_line = 0
      };
      original_column = ($truthy(($ret_or_1 = fragment.$column())) ? ($ret_or_1) : (0));
      if ($truthy(fragment.$source_map_name())) {
        
        map_name_index = ($truthy(($ret_or_1 = self.names_map['$[]'](fragment.$source_map_name().$to_s()))) ? ($ret_or_1) : ((($writer = [fragment.$source_map_name().$to_s(), self.names_map.$size()]), $send(self.names_map, '[]=', $to_a($writer)), $writer[$rb_minus($writer["length"], 1)])));
        return [generated_column, source_index, original_line, original_column, map_name_index];
      } else {
        return [generated_column, source_index, original_line, original_column]
      };
    }, 2);
    
    $def(self, '$relative_mappings', function $$relative_mappings() {
      var self = this, $ret_or_1 = nil, reference_segment = nil, reference_name_index = nil;

      return (self.relative_mappings = ($truthy(($ret_or_1 = self.relative_mappings)) ? ($ret_or_1) : (((reference_segment = [0, 0, 0, 0, 0]), (reference_name_index = 0), $send(self.$absolute_mappings(), 'map', [], function $$4(absolute_mapping){var $writer = nil;

        
        
        if (absolute_mapping == null) absolute_mapping = nil;;
        
        $writer = [0, 0];
        $send(reference_segment, '[]=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return $send(absolute_mapping, 'map', [], function $$5(absolute_segment){var segment = nil, $ret_or_2 = nil;

          
          
          if (absolute_segment == null) absolute_segment = nil;;
          segment = [];
          
          $writer = [0, $rb_minus(absolute_segment['$[]'](0), reference_segment['$[]'](0))];
          $send(segment, '[]=', $to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [1, $rb_minus(absolute_segment['$[]'](1), ($truthy(($ret_or_2 = reference_segment['$[]'](1))) ? ($ret_or_2) : (0)))];
          $send(segment, '[]=', $to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [2, $rb_minus(absolute_segment['$[]'](2), ($truthy(($ret_or_2 = reference_segment['$[]'](2))) ? ($ret_or_2) : (0)))];
          $send(segment, '[]=', $to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [3, $rb_minus(absolute_segment['$[]'](3), ($truthy(($ret_or_2 = reference_segment['$[]'](3))) ? ($ret_or_2) : (0)))];
          $send(segment, '[]=', $to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(absolute_segment['$[]'](4))) {
            
            
            $writer = [4, $rb_minus(absolute_segment['$[]'](4).$to_int(), ($truthy(($ret_or_2 = reference_segment['$[]'](4))) ? ($ret_or_2) : (reference_name_index)).$to_int())];
            $send(segment, '[]=', $to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            reference_name_index = absolute_segment['$[]'](4);
          };
          reference_segment = absolute_segment;
          return segment;}, 1);}, 1)))))
    }, 0);
    
    $def(self, '$absolute_mappings', function $$absolute_mappings() {
      var self = this, $ret_or_1 = nil, mappings = nil;

      return (self.absolute_mappings = ($truthy(($ret_or_1 = self.absolute_mappings)) ? ($ret_or_1) : (((mappings = []), $send(self.$fragments_by_line(), 'each', [], function $$6(raw_segments){var self = $$6.$$s == null ? this : $$6.$$s, generated_column = nil, segments = nil;

        
        
        if (raw_segments == null) raw_segments = nil;;
        generated_column = 0;
        segments = [];
        $send(raw_segments, 'each', [], function $$7($mlhs_tmp1){var $a, $b, self = $$7.$$s == null ? this : $$7.$$s, generated_code = nil, fragment = nil;

          
          
          if ($mlhs_tmp1 == null) $mlhs_tmp1 = nil;;
          $b = $mlhs_tmp1, $a = $to_ary($b), (generated_code = ($a[0] == null ? nil : $a[0])), (fragment = ($a[1] == null ? nil : $a[1])), $b;
          if (!($truthy(fragment['$is_a?']($$$($$('Opal'), 'Fragment'))) && ($truthy(fragment['$skip_source_map?']())))) {
            segments['$<<'](self.$segment_from_fragment(fragment, generated_column))
          };
          return (generated_column = $rb_plus(generated_column, generated_code.$size()));}, {$$arity: 1, $$s: self, $$has_top_level_mlhs_arg: true});
        return mappings['$<<'](segments);}, {$$arity: 1, $$s: self}), mappings))))
    }, 0);
    self.$private();
    return $def(self, '$fragments_by_line', function $$fragments_by_line() {
      var self = this, raw_mappings = nil;

      
      raw_mappings = [[]];
      $send(self.$fragments(), 'flat_map', [], function $$8(fragment){var fragment_code = nil, fragment_lines = nil;

        
        
        if (fragment == null) fragment = nil;;
        fragment_code = fragment.$code();
        fragment_lines = fragment_code.$split("\n", -1);
        return $send(fragment_lines.$each(), 'with_index', [], function $$9(fragment_line, index){var raw_segment = nil;

          
          
          if (fragment_line == null) fragment_line = nil;;
          
          if (index == null) index = nil;;
          raw_segment = [fragment_line, fragment];
          if (($truthy(index['$zero?']()) && ($not(fragment_line.$size()['$zero?']())))) {
            return raw_mappings.$last()['$<<'](raw_segment)
          } else if (($truthy(index['$zero?']()) && ($truthy(fragment_line.$size()['$zero?']())))) {
            return nil
          } else if ($truthy(fragment_line.$size()['$zero?']())) {
            return raw_mappings['$<<']([])
          } else {
            return raw_mappings['$<<']([raw_segment])
          };}, 2);}, 1);
      return raw_mappings;
    }, 0);
  })($$$($$('Opal'), 'SourceMap'), null, $nesting)
};

Opal.modules["opal/source_map/index"] = function(Opal) {/* Generated by Opal 1.4.0 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $hash2 = Opal.hash2, $def = Opal.def, $send = Opal.send, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('include,attr_reader,map,to_h,generated_code,+,count,[],rindex,size');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Index');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.source_maps = nil;
    
    self.$include($$$($$$($$('Opal'), 'SourceMap'), 'Map'));
    self.$attr_reader("source_maps");
    
    $def(self, '$initialize', function $$initialize(source_maps, $kwargs) {
      var join, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      join = $kwargs.$$smap["join"];
      if (join == null) join = nil;
      self.source_maps = source_maps;
      return (self.join = join);
    }, -2);
    return $def(self, '$map', function $$map() {
      var self = this, offset_line = nil, offset_column = nil;

      
      offset_line = 0;
      offset_column = 0;
      return $hash2(["version", "sections"], {"version": 3, "sections": $send(self.source_maps, 'map', [], function $$1(source_map){var self = $$1.$$s == null ? this : $$1.$$s, map = nil, generated_code = nil, new_lines_count = nil, last_line = nil;
        if (self.join == null) self.join = nil;

        
        
        if (source_map == null) source_map = nil;;
        map = $hash2(["offset", "map"], {"offset": $hash2(["line", "column"], {"line": offset_line, "column": offset_column}), "map": source_map.$to_h()});
        generated_code = source_map.$generated_code();
        if ($truthy(self.join)) {
          generated_code = $rb_plus(generated_code, self.join)
        };
        new_lines_count = generated_code.$count("\n");
        last_line = generated_code['$[]'](Opal.Range.$new($rb_plus(generated_code.$rindex("\n"), 1), -1, false));
        offset_line = $rb_plus(offset_line, new_lines_count);
        offset_column = $rb_plus(offset_column, last_line.$size());
        return map;}, {$$arity: 1, $$s: self})});
    }, 0);
  })($$$($$('Opal'), 'SourceMap'), null, $nesting)
};

Opal.modules["opal/source_map/vlq"] = function(Opal) {/* Generated by Opal 1.4.0 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $const_set = Opal.const_set, $rb_minus = Opal.rb_minus, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $defs = Opal.defs, $eqeq = Opal.eqeq;

  Opal.add_stubs('<<,-,split,inject,[],[]=,each,<,+,-@,loop,&,>>,>,|,join,any?,shift,raise,==,map,encode,each_with_index,decode');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'VLQ');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set($nesting[0], 'VLQ_BASE_SHIFT', 5);
    $const_set($nesting[0], 'VLQ_BASE', (1)['$<<']($$('VLQ_BASE_SHIFT')));
    $const_set($nesting[0], 'VLQ_BASE_MASK', $rb_minus($$('VLQ_BASE'), 1));
    $const_set($nesting[0], 'VLQ_CONTINUATION_BIT', $$('VLQ_BASE'));
    $const_set($nesting[0], 'BASE64_DIGITS', "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".$split(""));
    $const_set($nesting[0], 'BASE64_VALUES', $send($range(0, 64, true), 'inject', [$hash2([], {})], function $VLQ$1(h, i){var $writer = nil;

      
      
      if (h == null) h = nil;;
      
      if (i == null) i = nil;;
      
      $writer = [$$('BASE64_DIGITS')['$[]'](i), i];
      $send(h, '[]=', $to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return h;}, 2));
    $defs(self, '$encode', function $$encode(ary) {
      var self = this, result = nil;

      
      result = [];
      (function(){var $brk = Opal.new_brk(); try {return $send(ary, 'each', [], function $$2(n){var self = $$2.$$s == null ? this : $$2.$$s, vlq = nil;

        
        
        if (n == null) n = nil;;
        vlq = ($truthy($rb_lt(n, 0)) ? ($rb_plus(n['$-@']()['$<<'](1), 1)) : (n['$<<'](1)));
        return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$3(){var digit = nil;

          
          digit = vlq['$&']($$('VLQ_BASE_MASK'));
          vlq = vlq['$>>']($$('VLQ_BASE_SHIFT'));
          if ($truthy($rb_gt(vlq, 0))) {
            digit = digit['$|']($$('VLQ_CONTINUATION_BIT'))
          };
          result['$<<']($$('BASE64_DIGITS')['$[]'](digit));
          if ($truthy($rb_gt(vlq, 0))) {
            return nil
          } else {
            
            Opal.brk(nil, $brk)
          };}, {$$arity: 0, $$brk: $brk})
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();}, {$$arity: 1, $$s: self, $$brk: $brk})
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      return result.$join();
    }, 1);
    $defs(self, '$decode', function $$decode(str) {
      var $a, $b, self = this, result = nil, chars = nil, vlq = nil, shift = nil, continuation = nil, char$ = nil, digit = nil;

      
      result = [];
      chars = str.$split("");
      while ($truthy(chars['$any?']())) {
        
        vlq = 0;
        shift = 0;
        continuation = true;
        while ($truthy(continuation)) {
          
          char$ = chars.$shift();
          if (!$truthy(char$)) {
            self.$raise($$('ArgumentError'))
          };
          digit = $$('BASE64_VALUES')['$[]'](char$);
          if ($eqeq(digit['$&']($$('VLQ_CONTINUATION_BIT')), 0)) {
            continuation = false
          };
          digit = digit['$&']($$('VLQ_BASE_MASK'));
          vlq = $rb_plus(vlq, digit['$<<'](shift));
          shift = $rb_plus(shift, $$('VLQ_BASE_SHIFT'));
        };
        result['$<<'](($eqeq(vlq['$&'](1), 1) ? (vlq['$>>'](1)['$-@']()) : (vlq['$>>'](1))));
      };
      return result;
    }, 1);
    $defs(self, '$encode_mappings', function $$encode_mappings(ary) {
      var self = this;

      return $send(ary, 'map', [], function $$4(group){var self = $$4.$$s == null ? this : $$4.$$s;

        
        
        if (group == null) group = nil;;
        return $send(group, 'map', [], function $$5(segment){var self = $$5.$$s == null ? this : $$5.$$s;

          
          
          if (segment == null) segment = nil;;
          return self.$encode(segment);}, {$$arity: 1, $$s: self}).$join(",");}, {$$arity: 1, $$s: self}).$join(";")
    }, 1);
    return $defs(self, '$decode_mappings', function $$decode_mappings(str) {
      var self = this, mappings = nil;

      
      mappings = [];
      $send(str.$split(";"), 'each_with_index', [], function $$6(group, index){var self = $$6.$$s == null ? this : $$6.$$s, $writer = nil;

        
        
        if (group == null) group = nil;;
        
        if (index == null) index = nil;;
        
        $writer = [index, []];
        $send(mappings, '[]=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return $send(group.$split(","), 'each', [], function $$7(segment){var self = $$7.$$s == null ? this : $$7.$$s;

          
          
          if (segment == null) segment = nil;;
          return mappings['$[]'](index)['$<<'](self.$decode(segment));}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self});
      return mappings;
    }, 1);
  })($$$($$('Opal'), 'SourceMap'), $nesting)
};

Opal.modules["opal/source_map"] = function(Opal) {/* Generated by Opal 1.4.0 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module;

  Opal.add_stubs('autoload');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base) {
      var self = $module($base, 'SourceMap');

      
      
      self.$autoload("Map", "opal/source_map/map");
      self.$autoload("File", "opal/source_map/file");
      self.$autoload("Index", "opal/source_map/index");
      return self.$autoload("VLQ", "opal/source_map/vlq");
    })($nesting[0])
  })($nesting[0], $nesting)
};

Opal.modules["opal-source-maps"] = function(Opal) {/* Generated by Opal 1.4.0 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  return self.$require("opal/source_map")
};
