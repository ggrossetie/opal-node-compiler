Opal.modules["base64"] = function(Opal) {/* Generated by Opal 1.3.0 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$delete']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Base64');

    var $nesting = [self].concat($parent_nesting), $Base64_decode64$1, $Base64_encode64$2, $Base64_strict_decode64$3, $Base64_strict_encode64$4, $Base64_urlsafe_decode64$5, $Base64_urlsafe_encode64$6;

    
    
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var encode, decode;

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    encode = function (input) {
      var str = String(input);
      /* eslint-disable */
      for (
        // initialize result and counter
        var block, charCode, idx = 0, map = chars, output = '';
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = '=', idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3/4);
        if (charCode > 0xFF) {
          self.$raise($$($nesting, 'ArgumentError'), "invalid character (failed: The string to be encoded contains characters outside of the Latin1 range.)");
        }
        block = block << 8 | charCode;
      }
      return output;
      /* eslint-enable */
    };

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    decode = function (input) {
      var str = String(input).replace(/=+$/, '');
      if (str.length % 4 == 1) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid base64 (failed: The string to be decoded is not correctly encoded.)");
      }
      /* eslint-disable */
      for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
          // and if not first of each 4 characters,
          // convert the first 8 bits to one ascii character
          bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
      }
      return output;
      /* eslint-enable */
    };
  ;
    Opal.defs(self, '$decode64', $Base64_decode64$1 = function $$decode64(string) {
      var self = this;

      return decode(string.replace(/\r?\n/g, ''));
    }, $Base64_decode64$1.$$arity = 1);
    Opal.defs(self, '$encode64', $Base64_encode64$2 = function $$encode64(string) {
      var self = this;

      return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
    }, $Base64_encode64$2.$$arity = 1);
    Opal.defs(self, '$strict_decode64', $Base64_strict_decode64$3 = function $$strict_decode64(string) {
      var self = this;

      return decode(string);
    }, $Base64_strict_decode64$3.$$arity = 1);
    Opal.defs(self, '$strict_encode64', $Base64_strict_encode64$4 = function $$strict_encode64(string) {
      var self = this;

      return encode(string);
    }, $Base64_strict_encode64$4.$$arity = 1);
    Opal.defs(self, '$urlsafe_decode64', $Base64_urlsafe_decode64$5 = function $$urlsafe_decode64(string) {
      var self = this;

      return decode(string.replace(/\-/g, '+').replace(/_/g, '/'));
    }, $Base64_urlsafe_decode64$5.$$arity = 1);
    return (Opal.defs(self, '$urlsafe_encode64', $Base64_urlsafe_encode64$6 = function $$urlsafe_encode64(string, $kwargs) {
      var padding, self = this, str = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      padding = $kwargs.$$smap["padding"];
      if (padding == null) {
        padding = true
      };
      str = encode(string).replace(/\+/g, '-').replace(/\//g, '_');
      if ($truthy(padding)) {
      } else {
        str = str.$delete("=")
      };
      return str;
    }, $Base64_urlsafe_encode64$6.$$arity = -2), nil) && 'urlsafe_encode64';
  })($nesting[0], $nesting)
};

Opal.modules["json"] = function(Opal) {/* Generated by Opal 1.3.0 */
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$new', '$push', '$[]=', '$-', '$[]', '$create_id', '$json_create', '$const_get', '$attr_accessor', '$create_id=', '$===', '$parse', '$generate', '$from_object', '$merge', '$to_json', '$responds_to?', '$to_io', '$write', '$to_s', '$to_a', '$strftime']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'JSON');

    var $nesting = [self].concat($parent_nesting), $JSON_$$$1, $JSON_parse$2, $JSON_parse$excl$3, $JSON_load$4, $JSON_from_object$5, $JSON_generate$6, $JSON_dump$7, $writer = nil;

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'JSONError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ParserError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'JSONError'), $nesting);
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise($$$($$($nesting, 'JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'undefined':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (options.array_class).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (options.object_class).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                (($writer = [k, to_opal(value[k], options)]), $send((hash), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
              }
            }

            if (!options.parse && (klass = (hash)['$[]']($$($nesting, 'JSON').$create_id())) != nil) {
              return $$$('::', 'Object').$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    
    $writer = ["json_class"];
    $send(self, 'create_id=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    Opal.defs(self, '$[]', $JSON_$$$1 = function(value, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      if ($truthy($$($nesting, 'String')['$==='](value))) {
        return self.$parse(value, options)
      } else {
        return self.$generate(value, options)
      };
    }, $JSON_$$$1.$$arity = -2);
    Opal.defs(self, '$parse', $JSON_parse$2 = function $$parse(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$from_object($parse(source), options.$merge($hash2(["parse"], {"parse": true})));
    }, $JSON_parse$2.$$arity = -2);
    Opal.defs(self, '$parse!', $JSON_parse$excl$3 = function(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$parse(source, options);
    }, $JSON_parse$excl$3.$$arity = -2);
    Opal.defs(self, '$load', $JSON_load$4 = function $$load(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$from_object($parse(source), options);
    }, $JSON_load$4.$$arity = -2);
    Opal.defs(self, '$from_object', $JSON_from_object$5 = function $$from_object(js_object, options) {
      var self = this, $ret_or_1 = nil, $writer = nil, $ret_or_2 = nil;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      if ($truthy(($ret_or_1 = options['$[]']("object_class")))) {
        $ret_or_1
      } else {
        
        $writer = ["object_class", $$($nesting, 'Hash')];
        $send(options, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      if ($truthy(($ret_or_2 = options['$[]']("array_class")))) {
        $ret_or_2
      } else {
        
        $writer = ["array_class", $$($nesting, 'Array')];
        $send(options, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return to_opal(js_object, options.$$smap);;
    }, $JSON_from_object$5.$$arity = -2);
    Opal.defs(self, '$generate', $JSON_generate$6 = function $$generate(obj, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return obj.$to_json(options);
    }, $JSON_generate$6.$$arity = -2);
    return (Opal.defs(self, '$dump', $JSON_dump$7 = function $$dump(obj, io, limit) {
      var self = this, string = nil;

      
      
      if (io == null) {
        io = nil;
      };
      
      if (limit == null) {
        limit = nil;
      };
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()};
        io.$write(string);
        return io;
      } else {
        return string
      };
    }, $JSON_dump$7.$$arity = -2), nil) && 'dump';
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $Object_to_json$8;

    return (Opal.def(self, '$to_json', $Object_to_json$8 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, $Object_to_json$8.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_to_json$9;

    return (Opal.def(self, '$to_json', $Enumerable_to_json$9 = function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    }, $Enumerable_to_json$9.$$arity = 0), nil) && 'to_json'
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_to_json$10;

    return (Opal.def(self, '$to_json', $Array_to_json$10 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(',') + ']';
    
    }, $Array_to_json$10.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean_to_json$11;

    return (Opal.def(self, '$to_json', $Boolean_to_json$11 = function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, $Boolean_to_json$11.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_to_json$12;

    return (Opal.def(self, '$to_json', $Hash_to_json$12 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
      }

      return '{' + result.join(',') + '}';
    
    }, $Hash_to_json$12.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_to_json$13;

    return (Opal.def(self, '$to_json', $NilClass_to_json$13 = function $$to_json() {
      var self = this;

      return "null"
    }, $NilClass_to_json$13.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_to_json$14;

    return (Opal.def(self, '$to_json', $Numeric_to_json$14 = function $$to_json() {
      var self = this;

      return self.toString();
    }, $Numeric_to_json$14.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_json$15;

    return (Opal.def(self, '$to_json', $String_to_json$15 = function $$to_json() {
      var self = this;

      return JSON.stringify(self);
    }, $String_to_json$15.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_to_json$16;

    return (Opal.def(self, '$to_json', $Time_to_json$16 = function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    }, $Time_to_json$16.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Date');

    var $nesting = [self].concat($parent_nesting), $Date_to_json$17, $Date_as_json$18;

    
    
    Opal.def(self, '$to_json', $Date_to_json$17 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, $Date_to_json$17.$$arity = 0);
    return (Opal.def(self, '$as_json', $Date_as_json$18 = function $$as_json() {
      var self = this;

      return self.$to_s()
    }, $Date_as_json$18.$$arity = 0), nil) && 'as_json';
  })($nesting[0], null, $nesting);
};

Opal.modules["opal/source_map/map"] = function(Opal) {/* Generated by Opal 1.3.0 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$map', '$to_json', '$to_h', '$to_s', '$delete', '$encode64', '$generated_code']);
  
  self.$require("base64");
  self.$require("json");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Map');

    var $nesting = [self].concat($parent_nesting), $Map_to_h$1, $Map_to_json$2, $Map_as_json$3, $Map_to_s$4, $Map_to_data_uri_comment$5, $Map_cache$6, $Map_marshal_dump$7, $Map_marshal_load$8;

    
    
    Opal.def(self, '$to_h', $Map_to_h$1 = function $$to_h() {
      var self = this, $ret_or_1 = nil;
      if (self.to_h == null) self.to_h = nil;

      if ($truthy(($ret_or_1 = self.to_h))) {
        return $ret_or_1
      } else {
        return self.$map()
      }
    }, $Map_to_h$1.$$arity = 0);
    
    Opal.def(self, '$to_json', $Map_to_json$2 = function $$to_json() {
      var self = this;

      return self.$to_h().$to_json()
    }, $Map_to_json$2.$$arity = 0);
    
    Opal.def(self, '$as_json', $Map_as_json$3 = function $$as_json($a) {
      var $post_args, $rest_arg, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $rest_arg = $post_args;;
      return self.$to_h();
    }, $Map_as_json$3.$$arity = -1);
    
    Opal.def(self, '$to_s', $Map_to_s$4 = function $$to_s() {
      var self = this;

      return self.$to_h().$to_s()
    }, $Map_to_s$4.$$arity = 0);
    
    Opal.def(self, '$to_data_uri_comment', $Map_to_data_uri_comment$5 = function $$to_data_uri_comment() {
      var self = this;

      return "" + "//# sourceMappingURL=data:application/json;base64," + ($$($nesting, 'Base64').$encode64(self.$to_json()).$delete("\n"))
    }, $Map_to_data_uri_comment$5.$$arity = 0);
    
    Opal.def(self, '$cache', $Map_cache$6 = function $$cache() {
      var self = this, $ret_or_2 = nil;
      if (self.to_h == null) self.to_h = nil;

      
      self.to_h = (function() {if ($truthy(($ret_or_2 = self.to_h))) {
        return $ret_or_2
      } else {
        return self.$map()
      }; return nil; })();
      return self;
    }, $Map_cache$6.$$arity = 0);
    
    Opal.def(self, '$marshal_dump', $Map_marshal_dump$7 = function $$marshal_dump() {
      var self = this;

      return [self.$to_h(), self.$generated_code()]
    }, $Map_marshal_dump$7.$$arity = 0);
    return (Opal.def(self, '$marshal_load', $Map_marshal_load$8 = function $$marshal_load(value) {
      var $a, $b, self = this;

      return $b = value, $a = Opal.to_ary($b), (self.to_h = ($a[0] == null ? nil : $a[0])), (self.generated_code = ($a[1] == null ? nil : $a[1])), $b
    }, $Map_marshal_load$8.$$arity = 1), nil) && 'marshal_load';
  })($$$($$($nesting, 'Opal'), 'SourceMap'), $nesting);
};

Opal.modules["opal/source_map/file"] = function(Opal) {/* Generated by Opal 1.3.0 */
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$include', '$attr_reader', '$new', '$size', '$[]=', '$-', '$join', '$map', '$to_proc', '$file', '$force_encoding', '$source', '$names', '$encode_mappings', '$relative_mappings', '$absolute_mappings', '$sort_by', '$to_a', '$line', '$<', '$column', '$source_map_name', '$[]', '$to_s', '$to_int', '$each', '$fragments_by_line', '$is_a?', '$skip_source_map?', '$<<', '$segment_from_fragment', '$+', '$private', '$flat_map', '$fragments', '$code', '$split', '$with_index', '$zero?', '$!', '$last']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), $File_initialize$1, $File_generated_code$3, $File_map$4, $File_names$5, $File_segment_from_fragment$8, $File_relative_mappings$9, $File_absolute_mappings$12, $File_fragments_by_line$15;

    self.$$prototype.generated_code = self.$$prototype.fragments = self.$$prototype.names = self.$$prototype.names_map = self.$$prototype.relative_mappings = self.$$prototype.absolute_mappings = nil;
    
    self.$include($$$($$$($$($nesting, 'Opal'), 'SourceMap'), 'Map'));
    self.$attr_reader("fragments");
    self.$attr_reader("file");
    self.$attr_reader("source");
    
    Opal.def(self, '$initialize', $File_initialize$1 = function $$initialize(fragments, file, source, generated_code) {
      var $$2, self = this;

      
      
      if (generated_code == null) {
        generated_code = nil;
      };
      self.fragments = fragments;
      self.file = file;
      self.source = source;
      self.names_map = $send($$($nesting, 'Hash'), 'new', [], ($$2 = function(hash, name){var self = $$2.$$s == null ? this : $$2.$$s, $writer = nil;

        
        
        if (hash == null) {
          hash = nil;
        };
        
        if (name == null) {
          name = nil;
        };
        $writer = [name, hash.$size()];
        $send(hash, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$2.$$s = self, $$2.$$arity = 2, $$2));
      self.generated_code = generated_code;
      return (self.absolute_mappings = nil);
    }, $File_initialize$1.$$arity = -4);
    
    Opal.def(self, '$generated_code', $File_generated_code$3 = function $$generated_code() {
      var self = this, $ret_or_1 = nil;

      return (self.generated_code = (function() {if ($truthy(($ret_or_1 = self.generated_code))) {
        return $ret_or_1
      } else {
        return $send(self.fragments, 'map', [], "code".$to_proc()).$join()
      }; return nil; })())
    }, $File_generated_code$3.$$arity = 0);
    
    Opal.def(self, '$map', $File_map$4 = function $$map($kwargs) {
      var source_root, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      source_root = $kwargs.$$smap["source_root"];
      if (source_root == null) {
        source_root = ""
      };
      return $hash2(["version", "sourceRoot", "sources", "sourcesContent", "names", "mappings"], {"version": 3, "sourceRoot": source_root, "sources": [self.$file()], "sourcesContent": [self.$source().$force_encoding("UTF-8")], "names": self.$names(), "mappings": $$$($$$($$($nesting, 'Opal'), 'SourceMap'), 'VLQ').$encode_mappings(self.$relative_mappings())});
    }, $File_map$4.$$arity = -1);
    
    Opal.def(self, '$names', $File_names$5 = function $$names() {
      var $$6, $$7, self = this, $ret_or_2 = nil;

      return (self.names = (function() {if ($truthy(($ret_or_2 = self.names))) {
        return $ret_or_2
      } else {
        
        self.$absolute_mappings();
        return $send($send(self.names_map.$to_a(), 'sort_by', [], ($$6 = function(_, index){var self = $$6.$$s == null ? this : $$6.$$s;

          
          
          if (_ == null) {
            _ = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          return index;}, $$6.$$s = self, $$6.$$arity = 2, $$6)), 'map', [], ($$7 = function(name, _){var self = $$7.$$s == null ? this : $$7.$$s;

          
          
          if (name == null) {
            name = nil;
          };
          
          if (_ == null) {
            _ = nil;
          };
          return name;}, $$7.$$s = self, $$7.$$arity = 2, $$7));
      }; return nil; })())
    }, $File_names$5.$$arity = 0);
    
    Opal.def(self, '$segment_from_fragment', $File_segment_from_fragment$8 = function $$segment_from_fragment(fragment, generated_column) {
      var self = this, source_index = nil, original_line = nil, $ret_or_3 = nil, original_column = nil, $ret_or_4 = nil, map_name_index = nil, $ret_or_5 = nil, $writer = nil;

      
      source_index = 0;
      original_line = $rb_minus((function() {if ($truthy(($ret_or_3 = fragment.$line()))) {
        return $ret_or_3
      } else {
        return 0
      }; return nil; })(), 1);
      if ($truthy($rb_lt(original_line, 0))) {
        original_line = 0};
      original_column = (function() {if ($truthy(($ret_or_4 = fragment.$column()))) {
        return $ret_or_4
      } else {
        return 0
      }; return nil; })();
      if ($truthy(fragment.$source_map_name())) {
        
        map_name_index = (function() {if ($truthy(($ret_or_5 = self.names_map['$[]'](fragment.$source_map_name().$to_s())))) {
          return $ret_or_5
        } else {
          
          $writer = [fragment.$source_map_name().$to_s(), self.names_map.$size()];
          $send(self.names_map, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }; return nil; })();
        return [generated_column, source_index, original_line, original_column, map_name_index];
      } else {
        return [generated_column, source_index, original_line, original_column]
      };
    }, $File_segment_from_fragment$8.$$arity = 2);
    
    Opal.def(self, '$relative_mappings', $File_relative_mappings$9 = function $$relative_mappings() {
      var $$10, self = this, $ret_or_6 = nil, reference_segment = nil, reference_name_index = nil;

      return (self.relative_mappings = (function() {if ($truthy(($ret_or_6 = self.relative_mappings))) {
        return $ret_or_6
      } else {
        
        reference_segment = [0, 0, 0, 0, 0];
        reference_name_index = 0;
        return $send(self.$absolute_mappings(), 'map', [], ($$10 = function(absolute_mapping){var self = $$10.$$s == null ? this : $$10.$$s, $$11, $writer = nil;

          
          
          if (absolute_mapping == null) {
            absolute_mapping = nil;
          };
          
          $writer = [0, 0];
          $send(reference_segment, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return $send(absolute_mapping, 'map', [], ($$11 = function(absolute_segment){var self = $$11.$$s == null ? this : $$11.$$s, segment = nil, $ret_or_7 = nil, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil;

            
            
            if (absolute_segment == null) {
              absolute_segment = nil;
            };
            segment = [];
            
            $writer = [0, $rb_minus(absolute_segment['$[]'](0), reference_segment['$[]'](0))];
            $send(segment, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [1, $rb_minus(absolute_segment['$[]'](1), (function() {if ($truthy(($ret_or_7 = reference_segment['$[]'](1)))) {
              return $ret_or_7
            } else {
              return 0
            }; return nil; })())];
            $send(segment, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [2, $rb_minus(absolute_segment['$[]'](2), (function() {if ($truthy(($ret_or_8 = reference_segment['$[]'](2)))) {
              return $ret_or_8
            } else {
              return 0
            }; return nil; })())];
            $send(segment, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [3, $rb_minus(absolute_segment['$[]'](3), (function() {if ($truthy(($ret_or_9 = reference_segment['$[]'](3)))) {
              return $ret_or_9
            } else {
              return 0
            }; return nil; })())];
            $send(segment, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if ($truthy(absolute_segment['$[]'](4))) {
              
              
              $writer = [4, $rb_minus(absolute_segment['$[]'](4).$to_int(), (function() {if ($truthy(($ret_or_10 = reference_segment['$[]'](4)))) {
                return $ret_or_10
              } else {
                return reference_name_index
              }; return nil; })().$to_int())];
              $send(segment, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              reference_name_index = absolute_segment['$[]'](4);};
            reference_segment = absolute_segment;
            return segment;}, $$11.$$s = self, $$11.$$arity = 1, $$11));}, $$10.$$s = self, $$10.$$arity = 1, $$10));
      }; return nil; })())
    }, $File_relative_mappings$9.$$arity = 0);
    
    Opal.def(self, '$absolute_mappings', $File_absolute_mappings$12 = function $$absolute_mappings() {
      var $$13, self = this, $ret_or_11 = nil, mappings = nil;

      return (self.absolute_mappings = (function() {if ($truthy(($ret_or_11 = self.absolute_mappings))) {
        return $ret_or_11
      } else {
        
        mappings = [];
        $send(self.$fragments_by_line(), 'each', [], ($$13 = function(raw_segments){var self = $$13.$$s == null ? this : $$13.$$s, $$14, generated_column = nil, segments = nil;

          
          
          if (raw_segments == null) {
            raw_segments = nil;
          };
          generated_column = 0;
          segments = [];
          $send(raw_segments, 'each', [], ($$14 = function($mlhs_tmp1){var self = $$14.$$s == null ? this : $$14.$$s, $a, $b, generated_code = nil, fragment = nil, $ret_or_12 = nil;

            
            
            if ($mlhs_tmp1 == null) {
              $mlhs_tmp1 = nil;
            };
            $b = $mlhs_tmp1, $a = Opal.to_ary($b), (generated_code = ($a[0] == null ? nil : $a[0])), (fragment = ($a[1] == null ? nil : $a[1])), $b;
            if ($truthy((function() {if ($truthy(($ret_or_12 = fragment['$is_a?']($$$($$($nesting, 'Opal'), 'Fragment'))))) {
              return fragment['$skip_source_map?']()
            } else {
              return $ret_or_12
            }; return nil; })())) {
            } else {
              segments['$<<'](self.$segment_from_fragment(fragment, generated_column))
            };
            return (generated_column = $rb_plus(generated_column, generated_code.$size()));}, $$14.$$s = self, $$14.$$arity = 1, $$14.$$has_top_level_mlhs_arg = true, $$14));
          return mappings['$<<'](segments);}, $$13.$$s = self, $$13.$$arity = 1, $$13));
        return mappings;
      }; return nil; })())
    }, $File_absolute_mappings$12.$$arity = 0);
    self.$private();
    return (Opal.def(self, '$fragments_by_line', $File_fragments_by_line$15 = function $$fragments_by_line() {
      var $$16, self = this, raw_mappings = nil;

      
      raw_mappings = [[]];
      $send(self.$fragments(), 'flat_map', [], ($$16 = function(fragment){var self = $$16.$$s == null ? this : $$16.$$s, $$17, fragment_code = nil, fragment_lines = nil;

        
        
        if (fragment == null) {
          fragment = nil;
        };
        fragment_code = fragment.$code();
        fragment_lines = fragment_code.$split("\n", -1);
        return $send(fragment_lines.$each(), 'with_index', [], ($$17 = function(fragment_line, index){var self = $$17.$$s == null ? this : $$17.$$s, raw_segment = nil, $ret_or_13 = nil, $ret_or_14 = nil;

          
          
          if (fragment_line == null) {
            fragment_line = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          raw_segment = [fragment_line, fragment];
          if ($truthy((function() {if ($truthy(($ret_or_13 = index['$zero?']()))) {
            return fragment_line.$size()['$zero?']()['$!']()
          } else {
            return $ret_or_13
          }; return nil; })())) {
            return raw_mappings.$last()['$<<'](raw_segment)
          } else if ($truthy((function() {if ($truthy(($ret_or_14 = index['$zero?']()))) {
            return fragment_line.$size()['$zero?']()
          } else {
            return $ret_or_14
          }; return nil; })())) {
            return nil
          } else if ($truthy(fragment_line.$size()['$zero?']())) {
            return raw_mappings['$<<']([])
          } else {
            return raw_mappings['$<<']([raw_segment])
          };}, $$17.$$s = self, $$17.$$arity = 2, $$17));}, $$16.$$s = self, $$16.$$arity = 1, $$16));
      return raw_mappings;
    }, $File_fragments_by_line$15.$$arity = 0), nil) && 'fragments_by_line';
  })($$$($$($nesting, 'Opal'), 'SourceMap'), null, $nesting)
};

Opal.modules["opal/source_map/index"] = function(Opal) {/* Generated by Opal 1.3.0 */
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$attr_reader', '$map', '$to_h', '$generated_code', '$+', '$count', '$[]', '$rindex', '$size']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Index');

    var $nesting = [self].concat($parent_nesting), $Index_initialize$1, $Index_map$2;

    self.$$prototype.source_maps = nil;
    
    self.$include($$$($$$($$($nesting, 'Opal'), 'SourceMap'), 'Map'));
    self.$attr_reader("source_maps");
    
    Opal.def(self, '$initialize', $Index_initialize$1 = function $$initialize(source_maps, $kwargs) {
      var join, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      join = $kwargs.$$smap["join"];
      if (join == null) {
        join = nil
      };
      self.source_maps = source_maps;
      return (self.join = join);
    }, $Index_initialize$1.$$arity = -2);
    return (Opal.def(self, '$map', $Index_map$2 = function $$map() {
      var $$3, self = this, offset_line = nil, offset_column = nil;

      
      offset_line = 0;
      offset_column = 0;
      return $hash2(["version", "sections"], {"version": 3, "sections": $send(self.source_maps, 'map', [], ($$3 = function(source_map){var self = $$3.$$s == null ? this : $$3.$$s, map = nil, generated_code = nil, new_lines_count = nil, last_line = nil;
        if (self.join == null) self.join = nil;

        
        
        if (source_map == null) {
          source_map = nil;
        };
        map = $hash2(["offset", "map"], {"offset": $hash2(["line", "column"], {"line": offset_line, "column": offset_column}), "map": source_map.$to_h()});
        generated_code = source_map.$generated_code();
        if ($truthy(self.join)) {
          generated_code = $rb_plus(generated_code, self.join)};
        new_lines_count = generated_code.$count("\n");
        last_line = generated_code['$[]'](Opal.Range.$new($rb_plus(generated_code.$rindex("\n"), 1), -1, false));
        offset_line = $rb_plus(offset_line, new_lines_count);
        offset_column = $rb_plus(offset_column, last_line.$size());
        return map;}, $$3.$$s = self, $$3.$$arity = 1, $$3))});
    }, $Index_map$2.$$arity = 0), nil) && 'map';
  })($$$($$($nesting, 'Opal'), 'SourceMap'), null, $nesting)
};

Opal.modules["opal/source_map/vlq"] = function(Opal) {/* Generated by Opal 1.3.0 */
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$<<', '$-', '$split', '$inject', '$[]', '$[]=', '$each', '$<', '$+', '$-@', '$loop', '$&', '$>>', '$>', '$|', '$join', '$any?', '$shift', '$raise', '$==', '$map', '$encode', '$each_with_index', '$decode']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'VLQ');

    var $nesting = [self].concat($parent_nesting), $VLQ$1, $VLQ_encode$2, $VLQ_decode$5, $VLQ_encode_mappings$6, $VLQ_decode_mappings$9;

    
    Opal.const_set($nesting[0], 'VLQ_BASE_SHIFT', 5);
    Opal.const_set($nesting[0], 'VLQ_BASE', (1)['$<<']($$($nesting, 'VLQ_BASE_SHIFT')));
    Opal.const_set($nesting[0], 'VLQ_BASE_MASK', $rb_minus($$($nesting, 'VLQ_BASE'), 1));
    Opal.const_set($nesting[0], 'VLQ_CONTINUATION_BIT', $$($nesting, 'VLQ_BASE'));
    Opal.const_set($nesting[0], 'BASE64_DIGITS', "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".$split(""));
    Opal.const_set($nesting[0], 'BASE64_VALUES', $send($range(0, 64, true), 'inject', [$hash2([], {})], ($VLQ$1 = function(h, i){var self = $VLQ$1.$$s == null ? this : $VLQ$1.$$s, $writer = nil;

      
      
      if (h == null) {
        h = nil;
      };
      
      if (i == null) {
        i = nil;
      };
      
      $writer = [$$($nesting, 'BASE64_DIGITS')['$[]'](i), i];
      $send(h, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return h;}, $VLQ$1.$$s = self, $VLQ$1.$$arity = 2, $VLQ$1)));
    Opal.defs(self, '$encode', $VLQ_encode$2 = function $$encode(ary) {
      var $$3, self = this, result = nil;

      
      result = [];
      (function(){var $brk = Opal.new_brk(); try {return $send(ary, 'each', [], ($$3 = function(n){var self = $$3.$$s == null ? this : $$3.$$s, $$4, vlq = nil;

        
        
        if (n == null) {
          n = nil;
        };
        vlq = (function() {if ($truthy($rb_lt(n, 0))) {
          return $rb_plus(n['$-@']()['$<<'](1), 1)
        } else {
          return n['$<<'](1)
        }; return nil; })();
        return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$4 = function(){var self = $$4.$$s == null ? this : $$4.$$s, digit = nil;

          
          digit = vlq['$&']($$($nesting, 'VLQ_BASE_MASK'));
          vlq = vlq['$>>']($$($nesting, 'VLQ_BASE_SHIFT'));
          if ($truthy($rb_gt(vlq, 0))) {
            digit = digit['$|']($$($nesting, 'VLQ_CONTINUATION_BIT'))};
          result['$<<']($$($nesting, 'BASE64_DIGITS')['$[]'](digit));
          if ($truthy($rb_gt(vlq, 0))) {
            return nil
          } else {
            
            Opal.brk(nil, $brk)
          };}, $$4.$$s = self, $$4.$$brk = $brk, $$4.$$arity = 0, $$4))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();}, $$3.$$s = self, $$3.$$brk = $brk, $$3.$$arity = 1, $$3))
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      return result.$join();
    }, $VLQ_encode$2.$$arity = 1);
    Opal.defs(self, '$decode', $VLQ_decode$5 = function $$decode(str) {
      var $a, $b, self = this, result = nil, chars = nil, vlq = nil, shift = nil, continuation = nil, char$ = nil, digit = nil;

      
      result = [];
      chars = str.$split("");
      while ($truthy(chars['$any?']())) {
        
        vlq = 0;
        shift = 0;
        continuation = true;
        while ($truthy(continuation)) {
          
          char$ = chars.$shift();
          if ($truthy(char$)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'))
          };
          digit = $$($nesting, 'BASE64_VALUES')['$[]'](char$);
          if (digit['$&']($$($nesting, 'VLQ_CONTINUATION_BIT'))['$=='](0)) {
            continuation = false};
          digit = digit['$&']($$($nesting, 'VLQ_BASE_MASK'));
          vlq = $rb_plus(vlq, digit['$<<'](shift));
          shift = $rb_plus(shift, $$($nesting, 'VLQ_BASE_SHIFT'));
        };
        result['$<<']((function() {if (vlq['$&'](1)['$=='](1)) {
          return vlq['$>>'](1)['$-@']()
        } else {
          return vlq['$>>'](1)
        }; return nil; })());
      };
      return result;
    }, $VLQ_decode$5.$$arity = 1);
    Opal.defs(self, '$encode_mappings', $VLQ_encode_mappings$6 = function $$encode_mappings(ary) {
      var $$7, self = this;

      return $send(ary, 'map', [], ($$7 = function(group){var self = $$7.$$s == null ? this : $$7.$$s, $$8;

        
        
        if (group == null) {
          group = nil;
        };
        return $send(group, 'map', [], ($$8 = function(segment){var self = $$8.$$s == null ? this : $$8.$$s;

          
          
          if (segment == null) {
            segment = nil;
          };
          return self.$encode(segment);}, $$8.$$s = self, $$8.$$arity = 1, $$8)).$join(",");}, $$7.$$s = self, $$7.$$arity = 1, $$7)).$join(";")
    }, $VLQ_encode_mappings$6.$$arity = 1);
    return (Opal.defs(self, '$decode_mappings', $VLQ_decode_mappings$9 = function $$decode_mappings(str) {
      var $$10, self = this, mappings = nil;

      
      mappings = [];
      $send(str.$split(";"), 'each_with_index', [], ($$10 = function(group, index){var self = $$10.$$s == null ? this : $$10.$$s, $$11, $writer = nil;

        
        
        if (group == null) {
          group = nil;
        };
        
        if (index == null) {
          index = nil;
        };
        
        $writer = [index, []];
        $send(mappings, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return $send(group.$split(","), 'each', [], ($$11 = function(segment){var self = $$11.$$s == null ? this : $$11.$$s;

          
          
          if (segment == null) {
            segment = nil;
          };
          return mappings['$[]'](index)['$<<'](self.$decode(segment));}, $$11.$$s = self, $$11.$$arity = 1, $$11));}, $$10.$$s = self, $$10.$$arity = 2, $$10));
      return mappings;
    }, $VLQ_decode_mappings$9.$$arity = 1), nil) && 'decode_mappings';
  })($$$($$($nesting, 'Opal'), 'SourceMap'), $nesting)
};

Opal.modules["opal/source_map"] = function(Opal) {/* Generated by Opal 1.3.0 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  Opal.add_stubs(['$autoload']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'SourceMap');

      var $nesting = [self].concat($parent_nesting);

      
      self.$autoload("Map", "opal/source_map/map");
      self.$autoload("File", "opal/source_map/file");
      self.$autoload("Index", "opal/source_map/index");
      return self.$autoload("VLQ", "opal/source_map/vlq");
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal-source-maps"] = function(Opal) {/* Generated by Opal 1.3.0 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  return self.$require("opal/source_map")
};
